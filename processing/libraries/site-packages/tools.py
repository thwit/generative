import colorsys

# Converts a string (or a list of strings) of the format '#2a241b' to (r, g, b)
# Author: thw
def hex_to_rgb(h):
    if isinstance(h, list):
        cols = []
        for h_ in h:
            h_ = h_.lstrip('#')
            cols.append(tuple(int(h_[i:i+2], 16) for i in (0, 2, 4)))
        return cols
        
    h = h.lstrip('#')
    return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

def hex_to_hsb_helper(h):
    r, g, b = hex_to_rgb(h)
    r, g, b = [x/255.0 for x in [r, g, b]]
    h_, s, b = colorsys.rgb_to_hsv(r, g, b)
    return (h_ * 360, s * 100, b * 100)

def hex_to_hsb(h):
    if isinstance(h, list):
        cols = []
        for h_ in h:
            cols.append(hex_to_hsb_helper(h_))
        return cols
    return hex_to_hsb_helper(h)


# Returns the estimated length of bezier given a step
# Source: https://forum.processing.org/one/topic/methods-for-calculate-bezier-length.html
# Author: clankill3r
# Rewritten by: thw
def bezier_length(a1, c1, c2, a2, step=0.025):
    if not 0 <= step <= 1:
        raise ValueError('Step must be between 0 and 1 when computing bezier length')

    length = 0
    i = 0
    while (i+step <= 1):
        x_pos1 = bezierPoint(a1.x, c1.x, c2.x, a2.x, i)
        x_pos2 = bezierPoint(a1.x, c1.x, c2.x, a2.x, i+step)
        y_pos1 = bezierPoint(a1.y, c1.y, c2.y, a2.y, i)
        y_pos2 = bezierPoint(a1.y, c1.y, c2.y, a2.y, i+step)

        length += dist(x_pos1, y_pos1, x_pos2, y_pos2)
        i += step
    return length

# Adds noise to a 1D array with HSB colors
def noisify_brightness(arr, pg, noise=0.025):
    for i in range(len(arr)):
        r = random(1 - noise, 1 + noise)
        h = pg.hue(arr[i])
        s = pg.saturation(arr[i])
        b = pg.brightness(arr[i])
        arr[i] = pg.color(h, s, b*r)

def to_panto_a4(points, draw_width, draw_height, center=False):
    a4_width = 2100
    a4_height = 2970
    rob_width = 0.145
    rob_height = -0.105

    if draw_width > a4_width or draw_height > a4_height:
        raise ValueError('tools.to_panto_a4 - draw_width or draw_height is larger than a4 size!')

    
    if center:
        x_offset = (a4_width - draw_width) / 2
        y_offset = (a4_height - draw_height) / 2
    else:
        x_offset = 0
        y_offset = 0

    x = [p if isinstance(p, int) else map(p.x + x_offset, 0, a4_width, min(0, rob_width), max(0, rob_width)) for p in points]
    y = [p if isinstance(p, int) else map(p.y + y_offset, 0, a4_height, min(0, rob_height), max(0, rob_height)) for p in points]
    
    x_str = 'x = ' + str(x)
    y_str = 'y = ' + str(y)

    with open('panto.txt', 'w+') as f:
        f.write(x_str)
        f.write('\n')
        f.write(y_str)

def to_a4(points, draw_width, draw_height, center=True):
    a4_width = 2100
    a4_height = 2970
    
    if center:
        x_offset = (a4_width - draw_width) / 2
        y_offset = (a4_height - draw_height) / 2

    x = [p if isinstance(p, int) else p.x + x_offset for p in points]
    y = [p if isinstance(p, int) else p.y + y_offset for p in points]

    return x, y