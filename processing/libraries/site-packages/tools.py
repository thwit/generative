import colorsys

# Converts a string (or a list of strings) of the format '#2a241b' to (r, g, b)
# Author: thw
def hex_to_rgb(h):
    if isinstance(h, list):
        cols = []
        for h_ in h:
            h_ = h_.lstrip('#')
            cols.append(tuple(int(h_[i:i+2], 16) for i in (0, 2, 4)))
        return cols
        
    h = h.lstrip('#')
    return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

def hex_to_hsb_helper(h):
    r, g, b = hex_to_rgb(h)
    r, g, b = [x/255.0 for x in [r, g, b]]
    h_, s, b = colorsys.rgb_to_hsv(r, g, b)
    return (h_ * 360, s * 100, b * 100)

def hex_to_hsb(h):
    if isinstance(h, list):
        cols = []
        for h_ in h:
            cols.append(hex_to_hsb_helper(h_))
        return cols
    return hex_to_hsb_helper(h)


# Returns the estimated length of bezier given a step
# Source: https://forum.processing.org/one/topic/methods-for-calculate-bezier-length.html
# Author: clankill3r
# Rewritten by: thw
def bezier_length(a1, c1, c2, a2, step=0.025):
    
    
    if not 0 <= step <= 1:
        raise ValueError('Step must be between 0 and 1 when computing bezier length')

    length = 0
    i = 0
    while (i+step <= 1):
        x_pos1 = bezierPoint(a1.x, c1.x, c2.x, a2.x, i)
        x_pos2 = bezierPoint(a1.x, c1.x, c2.x, a2.x, i+step)
        y_pos1 = bezierPoint(a1.y, c1.y, c2.y, a2.y, i)
        y_pos2 = bezierPoint(a1.y, c1.y, c2.y, a2.y, i+step)

        length += dist(x_pos1, y_pos1, x_pos2, y_pos2)
        i += step
    
    return length

# Adds subtle noise to a 1D array
def noisify(arr, noise=0.05):
    pass
