import colorsys

# Converts a string (or a list of strings) of the format '#2a241b' to (r, g, b)
# Author: thw
def hex_to_rgb(h):
    if isinstance(h, list):
        cols = []
        for h_ in h:
            h_ = h_.lstrip('#')
            cols.append(tuple(int(h_[i:i+2], 16) for i in (0, 2, 4)))
        return cols
        
    h = h.lstrip('#')
    return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

def hex_to_hsb_helper(h):
    r, g, b = hex_to_rgb(h)
    r, g, b = [x/255.0 for x in [r, g, b]]
    h_, s, b = colorsys.rgb_to_hsv(r, g, b)
    return (h_ * 360, s * 100, b * 100)

def hex_to_hsb(h):
    if isinstance(h, list):
        cols = []
        for h_ in h:
            cols.append(hex_to_hsb_helper(h_))
        return cols
    return hex_to_hsb_helper(h)


# Returns the estimated length of bezier given a step
# Source: https://forum.processing.org/one/topic/methods-for-calculate-bezier-length.html
# Author: clankill3r
# Rewritten by: thw
def bezier_length(a1, c1, c2, a2, step=0.025):
    
    
    if not 0 <= step <= 1:
        raise ValueError('Step must be between 0 and 1 when computing bezier length')

    length = 0
    i = 0
    while (i+step <= 1):
        x_pos1 = bezierPoint(a1.x, c1.x, c2.x, a2.x, i)
        x_pos2 = bezierPoint(a1.x, c1.x, c2.x, a2.x, i+step)
        y_pos1 = bezierPoint(a1.y, c1.y, c2.y, a2.y, i)
        y_pos2 = bezierPoint(a1.y, c1.y, c2.y, a2.y, i+step)

        length += dist(x_pos1, y_pos1, x_pos2, y_pos2)
        i += step
    
    return length

# Adds noise to a 1D array with HSB colors
def noisify_brightness(arr, pg, noise=0.025):
    for i in range(len(arr)):
        r = random(1 - noise, 1 + noise)
        h = pg.hue(arr[i])
        s = pg.saturation(arr[i])
        b = pg.brightness(arr[i])
        arr[i] = pg.color(h, s, b*r)


def to_panto(ps, w, h):
    lim_x = 0.145
    lim_y = -0.105
    scale_ = min(w / abs(lim_x), h / abs(lim_y))

    for i, p in enumerate(ps):
        if not isinstance(p, PVector):
            continue # down, up
        else:
            p.x = p.x / scale_
            p.y = p.y / scale_ * -1

    return ps