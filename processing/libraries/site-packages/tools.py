import colorsys
import datetime
import json
import os
#from io import open


# Converts a string (or a list of strings) of the format '#2a241b' to (r, g, b)
# Author: thw


def hex_to_rgb(h):
    if isinstance(h, list):
        cols = []
        for h_ in h:
            h_ = h_.lstrip('#')
            cols.append(tuple(int(h_[i:i + 2], 16) for i in (0, 2, 4)))
        return cols

    h = h.lstrip('#')
    return tuple(int(h[i:i + 2], 16) for i in (0, 2, 4))


def hex_to_hsb_helper(h):
    r, g, b = hex_to_rgb(h)
    r, g, b = [x / 255.0 for x in [r, g, b]]
    h_, s, b = colorsys.rgb_to_hsv(r, g, b)
    return (h_ * 360, s * 100, b * 100)


def hex_to_hsb(h):
    if isinstance(h, list):
        cols = []
        for h_ in h:
            cols.append(hex_to_hsb_helper(h_))
        return cols
    return hex_to_hsb_helper(h)


# Returns the estimated length of bezier given a step
# Source: https://forum.processing.org/one/topic/methods-for-calculate-bezier-length.html
# Author: clankill3r
# Rewritten by: thw
def bezier_length(a1, c1, c2, a2, step=0.025):
    if not 0 <= step <= 1:
        raise ValueError(
            'Step must be between 0 and 1 when computing bezier length')

    length = 0
    i = 0
    while (i + step <= 1):
        x_pos1 = bezierPoint(a1.x, c1.x, c2.x, a2.x, i)
        x_pos2 = bezierPoint(a1.x, c1.x, c2.x, a2.x, i + step)
        y_pos1 = bezierPoint(a1.y, c1.y, c2.y, a2.y, i)
        y_pos2 = bezierPoint(a1.y, c1.y, c2.y, a2.y, i + step)

        length += dist(x_pos1, y_pos1, x_pos2, y_pos2)
        i += step
    return length

# Adds noise to a 1D array with HSB colors


def noisify_brightness(arr, pg, noise=0.025):
    for i in range(len(arr)):
        r = random(1 - noise, 1 + noise)
        h = pg.hue(arr[i])
        s = pg.saturation(arr[i])
        b = pg.brightness(arr[i])
        arr[i] = pg.color(h, s, b * r)


def to_panto_a4(points, draw_width, draw_height, center=False, upscale=True):
    a4_width = 2970
    a4_height = 2100
    rob_width = 0.145
    rob_height = -0.105

    if center and (draw_width > a4_width or draw_height > a4_height):
        raise ValueError(
            'tools.to_panto_a4 - draw_width or draw_height is larger than a4 size!')

    # Assume coordinates are drawn true to size on canvas with size (a4_width, a4_height) in units mm*10
    if not upscale:
        draw_width = a4_width
        draw_height = a4_height

    scale_ = max(draw_width / abs(rob_width), draw_height / abs(rob_height))

    # print(draw_width / abs(rob_width), draw_height / abs(rob_height))

    x = [p if isinstance(p, int) else p.x / scale_ for p in points]
    y = [p if isinstance(p, int) else p.y / scale_ * -1 for p in points]

    if center:
        x_offset = (
            rob_width - max(filter(lambda n: not isinstance(n, int), x))) / 2
        y_offset = (
            rob_height - min(filter(lambda n: not isinstance(n, int), y))) / 2

        print(x_offset, y_offset)

        for i in range(len(x)):
            if isinstance(x[i], int):
                continue

            x[i] += x_offset
            y[i] += y_offset

    x_str = 'x = ' + str(x)
    y_str = 'y = ' + str(y)

    with open('panto.txt', 'w+') as f:
        f.write(x_str)
        f.write('\n')
        f.write(y_str)


def save_image(pg, seed, palette_id=None):
    palette = ''
    if palette_id is not None:
        palette = '_palette_' + str(palette_id)

    filename = 'images/' + datetime.datetime.now().strftime('%d%b%Y-%H%M%S') + \
        '_seed_' + str(seed) + palette + '.png'
    pg.save(filename)
    pg.save('latest.png')


def get_color_palette(id_=None):
    cwd = os.getcwd()
    print(cwd)
    cwd = cwd[:cwd.index('processing') + len('processing')]
    #json_data = open(cwd + '\\libraries\\site-packages\\named-palettes.json', 'r', encoding='utf-8')
    json_data = open(cwd + '\\libraries\\site-packages\\named-palettes.json', 'rb',)

    try:
        colors = json.load(json_data)
    finally:
        json_data.close()

    if id_ is None or id_ <= 0 or id_ > len(colors):
        id_ = int(random(1, len(colors) + 1))

    cols = []

    for c in colors[id_ - 1]['colors']:
        cols.append(c['hex'])

    return cols, id_



if __name__ == "__main__":
    get_color_palette(1)
