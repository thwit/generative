def length(v):
    return sqrt(v.x*v.x + v.y*v.y)

def abs_vec(v):
    return PVector(abs(v.x), abs(v.y))
    
def max_vec(a, b):
    if isinstance(b, PVector):
        return PVector(max(a.x, b.x), max(a.y, b.y))
    elif isinstance(b, float):
        return max_vec(a, PVector(b, b))


def opUnion(d1, d2):
    return min(d1,d2)

def opSubtraction(d1, d2):
    return max(-d1,d2)

def opIntersection(d1, d2):
    return max(d1,d2)
    
def sdRep(x, r):
    x /= r
    x -= int(x) + .5
    x *= r
    return x

#vec2, vec2, float
def sdCircle(p, c, r):
    return length(p-c) - r
    
#vec2, vec2, float, float
def sdCircleAnnular(p, c, r, w):
    return abs(sdCircle(p, c, r)) - w

#vec2, vec2, float, float
def sdBox(p, c, w, h):

    d = abs_vec(p-c) - PVector(w, h)
    return length(max_vec(d,0.0)) + min(max(d.x,d.y),0.0)
    
#vec2, vec2, float, float, list(length=4) (roundness of each corner tr, br, tl, bl)
def sdRoundedBox(p, c, w, h, r):
    p_ = p
    r[:2] = r[:2] if p_.x > 0 else r[2:]
    r[0] = r[0] if p_.y > 0 else r[1]
    
    b = PVector(w, h)
    q = abs_vec(p_)-b
    q.x += r[0]
    q.y += r[0]
    
    return min(max(q.x,q.y),0.0) + length(max_vec(q,0.0)) - r[0]