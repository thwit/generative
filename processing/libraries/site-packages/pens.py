from __future__ import division
import math
import tools


class PenBasic(object):
    def __init__(self, pg, filler):
        self.pg = pg
        self.filler = filler
        self.stroke_weight = 1
        self.initial_stroke_weight = None
        self._fill = False
        self.fill_col = tools.hex_to_rgb('#ffffff')
        self._stroke = False
        self.stroke_col = tools.hex_to_rgb('#ffffff')

    def strokeWeight(self, weight):
        if self.initial_stroke_weight is None:
            self.initial_stroke_weight = weight

        weight = max(0, weight)
        self.pg.strokeWeight(weight)
        self.stroke_weight = weight

    def fill(self, col):
        if self.filler is None:
            return
        self._fill = True
        self.fill_col = col

    def noFill(self):
        if self.filler is None:
            return
        self._fill = False

    def stroke(self, col):
        self._stroke = True
        self.stroke_col = col
        self.pg.stroke(*col)

    def noStroke(self):
        self._stroke = False

    def line(self, v1, v2):
        if self._fill:
            self.filler.line(v1, v2, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.line(v1.x, v1.y, v2.x, v2.y)

    def circle(self, c, r):
        if self._fill:
            self.filler.circle(c, r, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.circle(c.x, c.y, 2 * r)

    def circle_xy(self, x, y, r):
        # if self._fill:
        #    self.filler.circle(c, r, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.circle(x, y, 2 * r)

    def arc(self, c, w, h, mode=OPEN):
        if self._fill:
            self.filler.arc(c, w, h, mode, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.arc(c.x, c.y, w, h, mode)

    def ellipse(self, c, w, h):
        if self._fill:
            self.filler.ellipse(c, w, h, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.ellipse(c.x, c.y, w, h)

    def point(self, c):
        if self._fill:
            self.filler.point(c, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.point(c.x, c.y)

    def quad(self, a, b, c, d):
        if self._fill:
            self.filler.quad(a, b, c, d, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.quad(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y)

    def rect(self, ul, w, h):
        if self._fill:
            self.filler.rect(ul, w, h, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.rect(ul.x, ul.y, w, h)

    def square(self, ul, s):
        if self._fill:
            self.filler.square(ul, s, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.square(ul.x, ul.y, s)

    def triangle(self, a, b, c):
        if self._fill:
            self.filler.triangle(a, b, c, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.triangle(a.x, a.y, b.x, b.y, c.x, c.y)

    def bezier(self, a1, c1, c2, a2):
        if self._fill:
            self.filler.bezier(a1, c1, c2, a2, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.strokeWeight(self.stroke_weight)
            self.pg.bezier(a1.x, a1.y, c1.x, c1.y, c2.x, c2.y, a2.x, a2.y)

    # Takes list of vectors
    def shape(self, vs):
        if self._fill:
            self.filler.shape(vs, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)

            self.pg.beginShape()
            for v in vs:
                self.pg.vertex(v.x, v.y)

            self.pg.endShape(OPEN)

    def shape_curve(self, vs):
        if len(vs) == 0:
            return

        if self._fill:
            self.filler.shape(vs, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)

            self.pg.beginShape()

            self.pg.curveVertex(vs[0].x, vs[0].y)

            for v in vs:
                self.pg.curveVertex(v.x, v.y)

            self.pg.curveVertex(vs[-1].x, vs[-1].y)

            self.pg.endShape(OPEN)

    def line_panto(self, v1, v2):
        v1_ = PVector(v1.x, v1.y)
        v2_ = PVector(v2.x, v2.y)
        return [v1_, -1, v2_, 1]

    def rect_panto(self, ul, w, h):
        v1 = PVector(ul.x, ul.y)
        v2 = PVector(ul.x, ul.y + h)
        v3 = PVector(ul.x + w, ul.y + h)
        v4 = PVector(ul.x + w, ul.y)
        v1_ = PVector(ul.x, ul.y)

        return [v1, -1, v2, v3, v4, v1_, 1]


# Draws straight lines pencil-like
# Source / inspiration:
# Author: antagoon
# URL:    https://editor.p5js.org/antigoon/sketches/55m6cqyIp
class PenRandom(PenBasic):
    def __init__(self, pg, filler):
        super(PenRandom, self).__init__(pg, filler)

    def _random_dots(self, dot_x, dot_y):
        dmi = 10
        rand = 1.25
        for _ in range(dmi):
            dir_x = random(-rand, rand)
            dir_y = random(-rand, rand)
            new_x = dot_x + dir_x
            new_y = dot_y + dir_y
            self.pg.circle(new_x, new_y, 1)

    def line(self, v1, v2):
        if self._fill:
            self.filler.line(PVector(v1.x, v1.y), PVector(v2.x, v2.y), self.fill_col)

        if not self._stroke:
            return

        x1, y1, x2, y2 = float(v1.x), float(v1.y), float(v2.x), float(v2.y)
        x_length = abs(x1 - x2)
        y_length = abs(y1 - y2)
        div_num = max(x_length, y_length)
        if div_num == 0:
            return
        div_x = abs(x2 - x1) / div_num
        div_y = abs(y2 - y1) / div_num

        div_num = int(div_num)

        self.pg.fill(*self.stroke_col)
        self.pg.noStroke()

        for i in range(div_num + 1):
            if(x1 < x2):
                new_x = x1 + div_x * i
            else:
                new_x = x1 - div_x * i
            if y1 < y2:
                new_y = y1 + div_y * i
            else:
                new_y = y1 - div_y * i

            self._random_dots(new_x, new_y)

        if not self._fill:
            self.noFill()

    def circle(self, c, r):
        if self._fill:
            self.filler.circle(PVector(c.x, c.y), r, self.fill_col)

        if not self._stroke:
            return

        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y
        rand = 0.7
        points = [(math.cos(2 * math.pi / n * x) * r + x_ + random(-rand, rand), math.sin(2 * math.pi / n * x) * r + y_ + random(-rand, rand)) for x in range(0, n + 1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            self.line(PVector(x, y), PVector(x_, y_))

            x_ = x
            y_ = y

    def rect(self, ul, w, h):
        if self._fill:
            self.filler.rect(ul, w, h, self.fill_col)

        if not self._stroke:
            return

        self.line(PVector(ul.x, ul.y), PVector(ul.x + w, ul.y))
        self.line(PVector(ul.x, ul.y), PVector(ul.x, ul.y + h))
        self.line(PVector(ul.x + w, ul.y), PVector(ul.x + w, ul.y + h))
        self.line(PVector(ul.x, ul.y + h), PVector(ul.x + w, ul.y + h))

# Like PenBasic but with gaps in its lines


class PenDash(PenBasic):
    def __init__(self, pg, filler):
        super(PenDash, self).__init__(pg, filler)
        self.prob = 0.15
        self.WIGGLEDEFAULT = 0.4
        self.wiggle = 0.4
        self.clean = False

    def set_clean(self, clean):
        self.clean = clean
        if clean:
            self.wiggle = 0
        else:
            self.wiggle = self.WIGGLEDEFAULT

    # Takes two PVector objects defining start and end point
    def line(self, v1, v2):
        steps = int((v1 - v2).mag() / 6)

        # Start x and y coordinate
        x_ = lerp(v1.x, v2.x, 0)
        y_ = lerp(v1.y, v2.y, 0)

        for i in range(1, steps + 1):
            t = i / steps
            x = lerp(v1.x, v2.x, t) + random(-self.wiggle, self.wiggle)
            y = lerp(v1.y, v2.y, t) + random(-self.wiggle, self.wiggle)

            if random(1) > self.prob:
                super(PenDash, self).line(PVector(x, y), PVector(x_, y_))
            elif not self.clean:
                self.strokeWeight(min(self.initial_stroke_weight * 2, max(1, self.stroke_weight + random(-0.5, 0.5))))

            x_ = x
            y_ = y

    def circle(self, c, r):
        if self._fill:
            self.filler.circle(PVector(c.x, c.y), r, self.fill_col)

        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y

        points = [(math.cos(2 * math.pi / n * x) * r + x_ + random(-self.wiggle, self.wiggle), math.sin(2 * math.pi / n * x) * r + y_ + random(-self.wiggle, self.wiggle)) for x in range(0, n + 1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            if random(1) > self.prob:
                super(PenDash, self).line(PVector(x, y), PVector(x_, y_))

            x_ = x
            y_ = y

    def rect(self, ul, w, h):
        if self._fill:
            self.filler.rect(ul, w, h, self.fill_col)

        self.line(ul, PVector(ul.x + w, ul.y))
        self.line(ul, PVector(ul.x, ul.y + h))
        self.line(PVector(ul.x + w, ul.y), PVector(ul.x + w, ul.y + h))
        self.line(PVector(ul.x, ul.y + h), PVector(ul.x + w, ul.y + h))

    def bezier(self, a1, c1, c2, a2):
        if self._fill:
            self.filler.bezier(a1, c1, c2, a2, self.fill_col)

        steps = int(tools.bezier_length(a1, c1, c2, a2) / 5)

        # Start x and y coordinate
        x_ = bezierPoint(a1.x, c1.x, c2.x, a2.x, 0)
        y_ = bezierPoint(a1.y, c1.y, c2.y, a2.y, 0)

        for i in range(1, steps + 1):
            t = i / steps
            x = bezierPoint(a1.x, c1.x, c2.x, a2.x, t)
            y = bezierPoint(a1.y, c1.y, c2.y, a2.y, t)

            if random(1) > self.prob:
                super(PenDash, self).line(PVector(x, y), PVector(x_, y_))

            x_ = x
            y_ = y


# Like PenRandom but with gaps in its lines
class PenDashRandom(PenRandom):
    def __init__(self, pg, filler):
        super(PenDashRandom, self).__init__(pg, filler)
        self.prob = 0.15
        self.WIGGLEDEFAULT = 0.4
        self.wiggle = 0.4
        self.clean = False

    def set_clean(self, clean):
        self.clean = clean
        if clean:
            self.wiggle = 0
        else:
            self.wiggle = self.WIGGLEDEFAULT

    # Takes two PVector objects defining start and end point
    def line(self, v1, v2):
        steps = int((v1 - v2).mag() / 5)

        # Start x and y coordinate
        x_ = lerp(v1.x, v2.x, 0)
        y_ = lerp(v1.y, v2.y, 0)

        for i in range(1, steps + 1):
            t = i / steps
            x = lerp(v1.x, v2.x, t) + random(-self.wiggle, self.wiggle)
            y = lerp(v1.y, v2.y, t) + random(-self.wiggle, self.wiggle)

            if random(1) > self.prob:
                super(PenDashRandom, self).line(PVector(x, y), PVector(x_, y_))

            x_ = x
            y_ = y

    def circle(self, c, r):
        if self._fill:
            self.filler.circle(c, r, self.fill_col)

        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y

        points = [(math.cos(2 * math.pi / n * x) * r + x_ + random(-self.wiggle, self.wiggle), math.sin(2 * math.pi / n * x) * r + y_ + random(-self.wiggle, self.wiggle)) for x in range(0, n + 1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            if random(1) > self.prob:
                super(PenDashRandom, self).line(PVector(x, y), PVector(x_, y_))

            x_ = x
            y_ = y

    def rect(self, ul, w, h):
        if self._fill:
            self.filler.rect(ul, w, h, self.fill_col)
        self.line(ul, PVector(ul.x + w, ul.y))
        self.line(ul, PVector(ul.x, ul.y + h))
        self.line(PVector(ul.x + w, ul.y), PVector(ul.x + w, ul.y + h))
        self.line(PVector(ul.x, ul.y + h), PVector(ul.x + w, ul.y + h))

    def bezier(self, a1, c1, c2, a2):
        steps = int(tools.bezier_length(a1, c1, c2, a2) / 5)

        # Start x and y coordinate
        x_ = bezierPoint(a1.x, c1.x, c2.x, a2.x, 0)
        y_ = bezierPoint(a1.y, c1.y, c2.y, a2.y, 0)
        for i in range(1, steps + 1):
            t = i / steps
            x = bezierPoint(a1.x, c1.x, c2.x, a2.x, t)
            y = bezierPoint(a1.y, c1.y, c2.y, a2.y, t)

            if random(1) > self.prob:
                super(PenDashRandom, self).line(PVector(x, y), PVector(x_, y_))

            x_ = x
            y_ = y


class PenBrush(PenBasic):
    def __init__(self, pg, filler):
        super(PenBrush, self).__init__(pg, filler)

        self._clean = 1

        self.wiggle = 1 * self._clean
        self.start_drag = 10 * self._clean
        self.end_drag = 4 * self._clean
        self.start_jiggle = 0.015 * self._clean * 0

        self.base_alpha = 5
        self.random_alpha = 5 * self._clean * 1
        self.random_brightness = 15 * self._clean * 1
        self.random_saturation = 5 * self._clean * 1
        self.random_hue = 5 * self._clean * 1
        self.random_strokeweight = 1 * self._clean * 1

        self.number_parallel = 400

        self.brush_width = 10

        self.col = None

    def set_config(self):
        self.wiggle = 1 * self._clean
        self.start_drag = 10 * self._clean
        self.end_drag = 4 * self._clean
        self.start_jiggle = 0.015 * self._clean * 1

        self.base_alpha = 33
        self.random_alpha = 5 * self._clean * 1
        self.random_brightness = 15 * self._clean * 1
        self.random_saturation = 5 * self._clean * 1
        self.random_hue = 5 * self._clean * 1
        self.random_strokeweight = 1 * self._clean * 1


    def line(self, v1, v2, d=10):
        self.brush_width = d
        self.number_parallel = d * 40


        self.col = self.stroke_col
        self.sw = self.stroke_weight

        u = v2 - v1
        u_ = v2 - v1
        u.normalize().rotate(radians(random(87, 93)))
        u_.normalize()

        for _ in range(self.number_parallel):

            rg = random(-1, 1)

            #v1_ = v1 + rg * self.brush_width * u + u_ * (randomGaussian() * (v1 - v2).mag() * self.start_drag_coef + 5)
            #v2_ = v2 + rg * self.brush_width * u + u_ * (randomGaussian() * (v1 - v2).mag() * self.end_drag_coef + 2)

            v1_ = v1 + rg * self.brush_width * u + u_ * randomGaussian() * self.start_drag
            v2_ = v2 + rg * self.brush_width * u + u_ * randomGaussian() * self.end_drag

            self.line2(v1_ * random(1 - self.start_jiggle, 1 + self.start_jiggle), v2_)

        self.stroke(self.col)
        self.strokeWeight(self.sw)

    def line2(self, v1, v2):
        steps = int((v1 - v2).mag() / 8)

        self.strokeWeight(randomGaussian() * 1.5 + 2)
        self.stroke((self.col[0] + randomGaussian() * self.random_hue, self.col[1] + randomGaussian() * self.random_saturation, self.col[2] + random(-1, 0) * self.random_brightness, randomGaussian() * self.random_alpha + self.base_alpha))
        points = []

        for i in range(0, steps + 1):
            if i != steps:
                t = i / steps
            else:
                t = 1
            x = lerp(v1.x, v2.x, t) + randomGaussian() * self.wiggle
            y = lerp(v1.y, v2.y, t) + randomGaussian() * self.wiggle

            if random(1) > 0.9 and len(points) >= 2:
                super(PenBrush, self).shape_curve(points)
                self.strokeWeight(randomGaussian() * self.random_strokeweight + 1)
                self.stroke((self.col[0] + randomGaussian() * self.random_hue, self.col[1] + randomGaussian() * self.random_saturation, self.col[2] + random(-1, 0) * self.random_brightness, randomGaussian() * self.random_alpha + self.base_alpha))

                points = []
            else:
                points.append(PVector(x, y))

        if random(1) > 0.1 and len(points) >= 2:
            super(PenBrush, self).shape_curve(points)
