from __future__ import division
import math

class Pen(object):
    def __init__(self, pg):
        self.pg = pg
        self.stroke_weight = 1
        self.initial_stroke_weight = None

    def line(self, v1, v2):
        self.pg.line(v1.x, v1.y, v2.x, v2.y)

    def circle(self, c, r):
        self.pg.circle(c.x, c.y, r)

    def arc(self, c, w, h, mode=OPEN):
        self.pg.arc(c.x, c.y, w, h, mode)

    def ellipse(self, c, w, h):
        self.pg.ellipse(c.x, c.y, w, h)

    def point(self, c):
        self.pg.point(c.x, c.y)

    def quad(self, a, b, c, d):
        self.pg.quad(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y)

    def rect(self, ul, w, h):
        self.pg.rect(ul.x, ul.y, w, h)

    def square(self, ul, s):
        self.pg.square(ul.x, ul.y, s)

    def triangle(self, a, b, c):
        self.pg.triangle(a.x, a.y, b.x, b.y, c.x, c.y)

    def strokeWeight(self, weight):
        if self.initial_stroke_weight is None:
            self.initial_stroke_weight = weight

        weight = max(0, weight)
        self.pg.strokeWeight(weight)
        self.stroke_weight = weight

# draws straight lines pencil-like
# Source / inspiration:
# Author: antagoon
# URL:    https://editor.p5js.org/antigoon/sketches/55m6cqyIp
class Pen2(Pen):
    def __init__(self, pg):
        super(Pen2, self).__init__(pg)
        
    def line(self, v1, v2):
        x1, y1, x2, y2 = float(v1.x), float(v1.y), float(v2.x), float(v2.y)
        x_length = abs(x1-x2)
        y_length = abs(y1-y2)
        div_num = max(x_length, y_length)
        if div_num == 0:
            return
        div_x = abs(x2-x1)/div_num
        div_y = abs(y2-y1)/div_num
        
        div_num = int(div_num)
        
        self.pg.fill(self.pg.strokeColor)
        self.pg.noStroke()


        for i in range(div_num+1):
            if(x1<x2):
                new_x = x1 + div_x * i
            else:
                new_x = x1 - div_x * i
            if y1 < y2:
                new_y = y1 + div_y * i
            else:
                new_y = y1 - div_y * i
                
            self._random_dots(new_x, new_y)

    def circle(self, c, r):
        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y
        rand = 0.7
        points = [(math.cos(2*math.pi/n*x)*r + x_ + random(-rand, rand), math.sin(2*math.pi/n*x)*r + y_ + random(-rand, rand)) for x in range(0,n+1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            self.line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y
        
    def _random_dots(self, dot_x, dot_y):

        dmi = 10
        rand = 1.25
        for _ in range(dmi):
            dir_x = random(-rand, rand)
            dir_y = random(-rand, rand)
            new_x = dot_x+dir_x
            new_y = dot_y+dir_y
            self.pg.circle(new_x, new_y, 1)


# Like Pen but with gaps in its lines
class Pen3(Pen):
    def __init__(self, pg):
        super(Pen3, self).__init__(pg)
        self.prob = 0.15
        self.rand = 0.4

    # Takes two PVector objects defining start and end point
    def line(self, v1, v2):
        steps = int((v1-v2).mag() / 5)
        
        # Start x and y coordinate
        x_ = lerp(v1.x, v2.x, 0)
        y_ = lerp(v1.y, v2.y, 0)

        for i in range(1, steps + 1):
            t = i / steps
            x = lerp(v1.x, v2.x, t) + random(-self.rand, self.rand)
            y = lerp(v1.y, v2.y, t) + random(-self.rand, self.rand)


            if random(1) > self.prob:
                super(Pen3, self).line(PVector(x,y), PVector(x_, y_))
            else:
                self.strokeWeight(min(self.initial_stroke_weight*2, max(1, self.stroke_weight + random(-0.5, 0.5))))

            x_ = x
            y_ = y

    def circle(self, c, r):
        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y

        points = [(math.cos(2*math.pi/n*x)*r + x_ + random(-self.rand, self.rand), math.sin(2*math.pi/n*x)*r + y_ + random(-self.rand, self.rand)) for x in range(0,n+1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            if random(1) > self.prob:
                super(Pen3, self).line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y

    def rect(self, ul, w, h):
        self.line(ul, PVector(ul.x + w, ul.y))
        self.line(ul, PVector(ul.x, ul.y + h))
        self.line(PVector(ul.x + w, ul.y), PVector(ul.x + w, ul.y + h))
        self.line(PVector(ul.x, ul.y + h), PVector(ul.x + w, ul.y + h))


# Like Pen2 but with gaps in its lines
class Pen3B(Pen2):
    def __init__(self, pg):
        super(Pen3B, self).__init__(pg)
        self.prob = 0.15
        self.rand = 0.4

    # Takes two PVector objects defining start and end point
    def line(self, v1, v2):
        steps = int((v1-v2).mag() / 5)
        
        # Start x and y coordinate
        x_ = lerp(v1.x, v2.x, 0)
        y_ = lerp(v1.y, v2.y, 0)

        for i in range(1, steps + 1):
            t = i / steps
            x = lerp(v1.x, v2.x, t) + random(-self.rand, self.rand)
            y = lerp(v1.y, v2.y, t) + random(-self.rand, self.rand)

            if random(1) > self.prob:
                super(Pen3B, self).line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y

    def circle(self, c, r):
        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y

        points = [(math.cos(2*math.pi/n*x)*r + x_ + random(-self.rand, self.rand), math.sin(2*math.pi/n*x)*r + y_ + random(-self.rand, self.rand)) for x in range(0,n+1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            if random(1) > self.prob:
                super(Pen3B, self).line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y


    def rect(self, ul, w, h):
        self.line(ul, PVector(ul.x + w, ul.y))
        self.line(ul, PVector(ul.x, ul.y + h))
        self.line(PVector(ul.x + w, ul.y), PVector(ul.x + w, ul.y + h))
        self.line(PVector(ul.x, ul.y + h), PVector(ul.x + w, ul.y + h))