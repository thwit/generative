from __future__ import division
import math
import tools

class PenBasic(object):
    def __init__(self, pg, filler):
        self.pg = pg
        self.filler = filler
        self.stroke_weight = 1
        self.initial_stroke_weight = None
        self._fill = False
        self.fill_col = tools.hex_to_rgb('#ffffff')
        self._stroke = False
        self.stroke_col = tools.hex_to_rgb('#ffffff')

    def strokeWeight(self, weight):
        if self.initial_stroke_weight is None:
            self.initial_stroke_weight = weight

        weight = max(0, weight)
        self.pg.strokeWeight(weight)
        self.stroke_weight = weight

    def fill(self, col):
        if self.filler is None:
            return
        self._fill = True
        self.fill_col = col

    def noFill(self):
        if self.filler is None:
            return
        self._fill = False

    def stroke(self, col):
        self._stroke = True
        self.stroke_col = col
        self.pg.stroke(*col)

    def noStroke(self):
        self._stroke = False

    def line(self, v1, v2):
        if self._fill:
            self.filler.line(v1, v2, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.line(v1.x, v1.y, v2.x, v2.y)

    def circle(self, c, r):
        if self._fill:
            self.filler.circle(c, r, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.circle(c.x, c.y, 2*r)

    def arc(self, c, w, h, mode=OPEN):
        if self._fill:
            self.filler.arc(c, w, h, mode, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.arc(c.x, c.y, w, h, mode)

    def ellipse(self, c, w, h):
        if self._fill:
            self.filler.ellipse(c, w, h, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.ellipse(c.x, c.y, w, h)

    def point(self, c):
        if self._fill:
            self.filler.point(c, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.point(c.x, c.y)

    def quad(self, a, b, c, d):
        if self._fill:
            self.filler.quad(a, b, c, d, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.quad(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y)

    def rect(self, ul, w, h):
        if self._fill:
            self.filler.rect(ul, w, h, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.rect(ul.x, ul.y, w, h)

    def square(self, ul, s):
        if self._fill:
            self.filler.square(ul, s, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.square(ul.x, ul.y, s)

    def triangle(self, a, b, c):
        if self._fill:
            self.filler.triangle(a, b, c, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.triangle(a.x, a.y, b.x, b.y, c.x, c.y)

    def bezier(self, a1, c1, c2, a2):
        if self._fill:
            self.filler.bezier(a1, c1, c2, a2, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)
            self.pg.bezier(a1.x, a1.y, c1.x, c1.y, c2.x, c2.y, a2.x, a2.y)

    # Takes list of vectors
    def shape(self, vs):
        if self._fill:
            self.filler.shape(vs, self.fill_col)

        if self._stroke:
            self.stroke(self.stroke_col)

            self.pg.beginShape()
            for v in vs:
                self.pg.vertex(v.x, v.y)

            self.pg.endShape(CLOSE)


# Draws straight lines pencil-like
# Source / inspiration:
# Author: antagoon
# URL:    https://editor.p5js.org/antigoon/sketches/55m6cqyIp
class PenRandom(PenBasic):
    def __init__(self, pg, filler):
        super(PenRandom, self).__init__(pg, filler)
        
    def _random_dots(self, dot_x, dot_y):
        dmi = 10
        rand = 1.25
        for _ in range(dmi):
            dir_x = random(-rand, rand)
            dir_y = random(-rand, rand)
            new_x = dot_x+dir_x
            new_y = dot_y+dir_y
            self.pg.circle(new_x, new_y, 1)
        
    def line(self, v1, v2):
        if self._fill:
            self.filler.line(PVector(v1.x, v1.y), PVector(v2.x, v2.y), self.fill_col)
            if self.fill_col == self.stroke_col:
                return

        if not self._stroke:
            return

        x1, y1, x2, y2 = float(v1.x), float(v1.y), float(v2.x), float(v2.y)
        x_length = abs(x1-x2)
        y_length = abs(y1-y2)
        div_num = max(x_length, y_length)
        if div_num == 0:
            return
        div_x = abs(x2-x1)/div_num
        div_y = abs(y2-y1)/div_num
        
        div_num = int(div_num)
        
        self.pg.fill(*self.stroke_col)
        self.pg.noStroke()


        for i in range(div_num+1):
            if(x1<x2):
                new_x = x1 + div_x * i
            else:
                new_x = x1 - div_x * i
            if y1 < y2:
                new_y = y1 + div_y * i
            else:
                new_y = y1 - div_y * i
                
            self._random_dots(new_x, new_y)

        if not self._fill:
            self.noFill()

    def circle(self, c, r):
        if self._fill:
            self.filler.circle(PVector(c.x, c.y), r, self.fill_col)
            if self.fill_col == self.stroke_col:
                return

        if not self._stroke:
            return

        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y
        rand = 0.7
        points = [(math.cos(2*math.pi/n*x)*r + x_ + random(-rand, rand), math.sin(2*math.pi/n*x)*r + y_ + random(-rand, rand)) for x in range(0,n+1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            self.line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y

    def rect(self, ul, w, h):
        if self._fill:
            self.filler.rect(ul, w, h, self.fill_col)
            if self.fill_col == self.stroke_col:
                return

        if not self._stroke:
            return

        self.line(PVector(ul.x, ul.y), PVector(ul.x + w, ul.y))
        self.line(PVector(ul.x, ul.y), PVector(ul.x, ul.y + h))
        self.line(PVector(ul.x + w, ul.y), PVector(ul.x + w, ul.y + h))
        self.line(PVector(ul.x, ul.y + h), PVector(ul.x + w, ul.y + h))

# Like PenBasic but with gaps in its lines
class PenDash(PenBasic):
    def __init__(self, pg, filler):
        super(PenDash, self).__init__(pg, filler)
        self.prob = 0.15
        self.WIGGLEDEFAULT = 0.4
        self.wiggle = 0.4
        self.clean = False

    def set_clean(self, clean):
        self.clean = clean
        if clean:
            self.wiggle = 0
        else:
            self.wiggle = self.WIGGLEDEFAULT

    # Takes two PVector objects defining start and end point
    def line(self, v1, v2):
        steps = int((v1-v2).mag() / 6)
        
        # Start x and y coordinate
        x_ = lerp(v1.x, v2.x, 0)
        y_ = lerp(v1.y, v2.y, 0)

        for i in range(1, steps + 1):
            t = i / steps
            x = lerp(v1.x, v2.x, t) + random(-self.wiggle, self.wiggle)
            y = lerp(v1.y, v2.y, t) + random(-self.wiggle, self.wiggle)


            if random(1) > self.prob:
                super(PenDash, self).line(PVector(x,y), PVector(x_, y_))
            elif not self.clean:
                self.strokeWeight(min(self.initial_stroke_weight*2, max(1, self.stroke_weight + random(-0.5, 0.5))))

            x_ = x
            y_ = y

    def circle(self, c, r):
        if self._fill:
            self.filler.circle(PVector(c.x, c.y), r, self.fill_col)

        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y

        points = [(math.cos(2*math.pi/n*x)*r + x_ + random(-self.wiggle, self.wiggle), math.sin(2*math.pi/n*x)*r + y_ + random(-self.wiggle, self.wiggle)) for x in range(0,n+1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            if random(1) > self.prob:
                super(PenDash, self).line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y

    def rect(self, ul, w, h):
        if self._fill:
            self.filler.rect(ul, w, h, self.fill_col)

        self.line(ul, PVector(ul.x + w, ul.y))
        self.line(ul, PVector(ul.x, ul.y + h))
        self.line(PVector(ul.x + w, ul.y), PVector(ul.x + w, ul.y + h))
        self.line(PVector(ul.x, ul.y + h), PVector(ul.x + w, ul.y + h))

    def bezier(self, a1, c1, c2, a2):
        if self._fill:
            self.filler.bezier(a1, c1, c2, a2, self.fill_col)

        steps = int(tools.bezier_length(a1, c1, c2, a2) / 5)
        
        # Start x and y coordinate
        x_ = bezierPoint(a1.x, c1.x, c2.x, a2.x, 0)
        y_ = bezierPoint(a1.y, c1.y, c2.y, a2.y, 0)

        for i in range(1, steps + 1):
            t = i / steps
            x = bezierPoint(a1.x, c1.x, c2.x, a2.x, t)
            y = bezierPoint(a1.y, c1.y, c2.y, a2.y, t)

            if random(1) > self.prob:
                super(PenDash, self).line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y


# Like PenRandom but with gaps in its lines
class PenDashRandom(PenRandom):
    def __init__(self, pg, filler):
        super(PenDashRandom, self).__init__(pg, filler)
        self.prob = 0.15
        self.WIGGLEDEFAULT = 0.4
        self.wiggle = 0.4
        self.clean = False

    def set_clean(self, clean):
        self.clean = clean
        if clean:
            self.wiggle = 0
        else:
            self.wiggle = self.WIGGLEDEFAULT

    # Takes two PVector objects defining start and end point
    def line(self, v1, v2):
        steps = int((v1-v2).mag() / 5)
        
        # Start x and y coordinate
        x_ = lerp(v1.x, v2.x, 0)
        y_ = lerp(v1.y, v2.y, 0)

        for i in range(1, steps + 1):
            t = i / steps
            x = lerp(v1.x, v2.x, t) + random(-self.wiggle, self.wiggle)
            y = lerp(v1.y, v2.y, t) + random(-self.wiggle, self.wiggle)

            if random(1) > self.prob:
                super(PenDashRandom, self).line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y

    def circle(self, c, r):
        if self._fill:
            self.filler.circle(c, r, self.fill_col)

        n = int(2 * math.pi * r / 5)
        x_ = c.x
        y_ = c.y

        points = [(math.cos(2*math.pi/n*x)*r + x_ + random(-self.wiggle, self.wiggle), math.sin(2*math.pi/n*x)*r + y_ + random(-self.wiggle, self.wiggle)) for x in range(0,n+1)]

        x_, y_ = points[0]

        for x, y in points[1:]:
            if random(1) > self.prob:
                super(PenDashRandom, self).line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y

    def rect(self, ul, w, h):
        if self._fill:
            self.filler.rect(ul, w, h, self.fill_col)
        self.line(ul, PVector(ul.x + w, ul.y))
        self.line(ul, PVector(ul.x, ul.y + h))
        self.line(PVector(ul.x + w, ul.y), PVector(ul.x + w, ul.y + h))
        self.line(PVector(ul.x, ul.y + h), PVector(ul.x + w, ul.y + h))

    def bezier(self, a1, c1, c2, a2):
        steps = int(tools.bezier_length(a1, c1, c2, a2) / 5)
        
        # Start x and y coordinate
        x_ = bezierPoint(a1.x, c1.x, c2.x, a2.x, 0)
        y_ = bezierPoint(a1.y, c1.y, c2.y, a2.y, 0)
        for i in range(1, steps + 1):
            t = i / steps
            x = bezierPoint(a1.x, c1.x, c2.x, a2.x, t)
            y = bezierPoint(a1.y, c1.y, c2.y, a2.y, t)

            if random(1) > self.prob:
                super(PenDashRandom, self).line(PVector(x,y), PVector(x_, y_))

            x_ = x
            y_ = y