import math

# BasicFill works like default processing fills
class BasicFill(object):
    def __init__(self, pg):
        self.pg = pg

    def line(self, v1, v2, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.line(v1.x, v1.y, v2.x, v2.y)

    def circle(self, c, r, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.circle(c.x, c.y, 2*r)

    def arc(self, c, w, h, mode, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.arc(c.x, c.y, w, h, mode)

    def ellipse(self, c, w, h, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.ellipse(c.x, c.y, w, h)

    def point(self, c, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.point(c.x, c.y)

    def quad(self, a, b, c, d, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.quad(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y)

    def rect(self, ul, w, h, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.rect(ul.x, ul.y, w, h)

    def square(self, ul, s, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.square(ul.x, ul.y, s)

    def triangle(self, a, b, c, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.triangle(a.x, a.y, b.x, b.y, c.x, c.y)

    def bezier(self, a1, c1, c2, a2, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.bezier(a1.x, a1.y, c1.x, c1.y, c2.x, c2.y, a2.x, a2.y)

# Fills color by layering many transparent layers of the color
class LayerFill(BasicFill):
    def __init__(self, pg):
        super(LayerFill, self).__init__(pg)

    def circle(self, c, r, col):
        self.pg.noStroke()
        self.pg.fill(col[0], col[1], col[2], 3)
        #self.pg.fill(*col)


        for _ in range(225):
            # random angle
            alpha = 2 * math.pi * random(1)

            r_ = random(r)

            # calculating coordinates
            x = r_ * math.cos(alpha) + c.x
            y = r_ * math.sin(alpha) + c.y

            r_fill = r - r_

            self.pg.circle(x, y, 2 * r_fill)

        
        self.pg.noFill()