import math
import geometry as gm
import pens

# BasicFill works like default processing fills
class BasicFill(object):
    def __init__(self, pg):
        self.pg = pg

    def line(self, v1, v2, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.line(v1.x, v1.y, v2.x, v2.y)
        self.pg.noFill()

    def circle(self, c, r, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.circle(c.x, c.y, 2*r)
        self.pg.noFill()

    def arc(self, c, w, h, mode, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.arc(c.x, c.y, w, h, mode)
        self.pg.noFill()

    def ellipse(self, c, w, h, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.ellipse(c.x, c.y, w, h)
        self.pg.noFill()

    def point(self, c, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.point(c.x, c.y)
        self.pg.noFill()

    def quad(self, a, b, c, d, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.quad(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y)
        self.pg.noFill()

    def rect(self, ul, w, h, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.rect(ul.x, ul.y, w, h)
        self.pg.noFill()

    def square(self, ul, s, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.square(ul.x, ul.y, s)
        self.pg.noFill()

    def triangle(self, a, b, c, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.triangle(a.x, a.y, b.x, b.y, c.x, c.y)
        self.pg.noFill()

    def bezier(self, a1, c1, c2, a2, col):
        self.pg.noStroke()
        self.pg.fill(*col)
        self.pg.bezier(a1.x, a1.y, c1.x, c1.y, c2.x, c2.y, a2.x, a2.y)
        self.pg.noFill()

    def shape(self, vs, col):
        self.pg.noStroke()
        self.pg.fill(*col)

        self.pg.beginShape()
        for v in vs:
            self.pg.vertex(v.x, v.y)

        self.pg.endShape(CLOSE)

        self.pg.noFill()

# Fills color by layering many transparent layers of the color
class LayerFill(BasicFill):
    def __init__(self, pg):
        super(LayerFill, self).__init__(pg)

    def circle(self, c, r, col):
        self.pg.noStroke()
        self.pg.fill(col[0], col[1], col[2], 3)

        v = PVector(0,0)
        for _ in range(5):
            # random angle
            alpha = 2 * TWO_PI * random(1)

            r_ = r * sqrt(random(1))

            # calculating coordinates
            v.x = r_ * cos(alpha) + c.x
            v.y = r_ * sin(alpha) + c.y

            r_fill = r - r_
            #self.pg.circle(v.x, v.y, r/4)
            self._splash(v, r/4, col)

        
        self.pg.noFill()

    def rect2(self, ul, w, h, col):
        self.pg.noStroke()
        self.pg.fill(col[0], col[1], col[2], 3)
        max_x = ul.x + w
        max_y = ul.y + h
        self.pg.rectMode(CENTER)

        for _ in range(2500):
            x = ul.x + random(1) * w
            y = ul.y + random(1) * h

            w_ = min(max_x - x, x - ul.x)
            h_ = min(max_y - y, y - ul.y)

            self.pg.rect(x, y, w_, h_)

        
        self.pg.rectMode(CORNER)


    def rect(self, ul, w, h, col):
        self.pg.noStroke()
        self.pg.fill(col[0], col[1], col[2], 3)

        max_x = ul.x + w
        max_y = ul.y + h

        min_x = ul.x 
        min_y = ul.y

        v = PVector(0, 0)

        for _ in range(500):
            v.x = ul.x + random(1) * w
            v.y = ul.y + random(1) * h

            w_ = min(abs(max_x - v.x), abs(min_x - v.x))
            h_ = min(abs(max_y - v.y), abs(min_y - v.y))

            self._splash(v, min(w_, h_) * 1.1, col)

        self.pg.noFill()


    def _splash(self, c, r, col):
        p = gm.DeformedPolygon(c.x, c.y, r, 10)
        for _ in range(100):
            p_ = p.deform()
            self._shape_once(p_.points, col)

    def _shape_once(self, vs, col):
        self.pg.beginShape()
        for v in vs:
            self.pg.vertex(v.x, v.y)

        self.pg.endShape(CLOSE)


class ScannerFill(BasicFill):
    def __init__(self, pg):
        super(ScannerFill, self).__init__(pg)
        self.pen = pens.PenRandom(pg, self)
        self.step = 2.5

    def rect(self, ul, w, h, col):
        self.pen.noStroke()
        self.pen.stroke(col)
        self.pen.noFill()

        x = ul.x + self.step / 5
        while x < ul.x+w - self.step / 5:
            self.pen.line(PVector(x, ul.y + self.step / 5), PVector(x, ul.y + h - self.step / 5))
            x += self.step

        self.pen.noStroke()
        self.pen.noFill()

    def circle(self, c, r, col):
        self.pen.noStroke()
        self.pen.stroke(col)
        self.pen.noFill()
        
        xs = []

        x = c.x - r
        while x < c.x + r:
            xs.append(x)
            x += self.step
        
        points = []
        for x in xs:
            d = r**2 - (x - c.x)**2
            if d > 0:
                y = sqrt(d) + c.y
            else:
                continue
            points.append((x, y))

        for x, y in points:
            y_diff = y - c.y
            self.pen.line(PVector(x, y), PVector(x, y-y_diff*2))


        self.pen.noStroke()
        self.pen.noFill()

    def triangle(self, a, b, c, col):
        pass

class LineFill(BasicFill):
    def __init__(self, pg):
        super(LineFill, self).__init__(pg)
        self.pen = pens.PenBasic(pg, self)
        self.margin = 0
        self.dist = 0.25
        self.size = 25

    def rect(self, ul, w, h, col):
        self.pen.strokeWeight(1)
        self.pen.stroke((col[0], col[1], col[2], 33))

        for _ in range(15000):
            v1 = PVector(random(ul.x - self.margin * w, ul.y + (1 + self.margin) * w), random(ul.y - self.margin * h, ul.y + (1 + self.margin) * h))
            v2 = PVector(random(ul.x - self.margin * w, ul.y + (1 + self.margin) * w), random(ul.y - self.margin * h, ul.y + (1 + self.margin) * h))

            self.pen.line(v1, v1 + (v1 - v2).normalize() * self.size)

    def circle(self, c, r, col):
        self.pen.strokeWeight(1)
        self.pen.stroke((col[0], col[1], col[2], 50))

        v1 = PVector(0, 0)
        v2 = PVector(0, 0)

        for _ in range(15000):
            # random angle
            alpha = 2 * TWO_PI * random(1)

            r_ = r * sqrt(random(1))

            # calculating coordinates
            v1.x = r_ * cos(alpha) + c.x
            v1.y = r_ * sin(alpha) + c.y

            alpha = 2 * TWO_PI * random(1)

            if random(1) < 0.1:
                r_ = random(r)
            else:
                r_ = r * sqrt(random(1))

            v2.x = r_ * cos(alpha) + c.x
            v2.y = r_ * sin(alpha) + c.y


            self.pen.line(v1, v1 + (v1 - v2).normalize() * self.size)

        
        self.pen.noFill()