class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
        
    def intersects(self, other):
        return (self.x-other.x)**2 + (self.y-other.y)**2 <= (self.r+other.r)**2 
    
    # Takes a circle or x, y coordinates
    # Returns true if argument has origin inside self circle
    def inside(self, c_or_x, y=None):
        if y is None:
            x = c_or_x.x
            y = c_or_x.y
        else:
            x = c_or_x
        
        return (sq(self.x - x) + sq(self.y - y)) < sq(self.r)
    
    def inside_list(self, circles):
        for c in circles:
            if c.inside(self):
                return True
        return False
    
    def intersects_list(self, circles):
        for c in circles:
            if self.intersects(c):
                return True
        return False
    
    def draw(self, pen):
        pen.circle(PVector(self.x, self.y), self.r)


class Rect(object):
    def __init__(self, x, y, w, h, strk_col, fill_col=None):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.strk_col = strk_col
        self.fill_col = fill_col
        self.circle_pack = None
        
    def circle_pack(self, col):
        self.circle_pack = CirclePack(self.x, self.y, self.w, self.h, 100, 2, 100, col).generate()

    def draw(self, pen):
        pg = pen.pg

        if self.circle_pack is not None:
            self.circle_pack.draw(pen)

        pg.stroke(*self.strk_col)

        if self.fill_col is None:
            pg.noFill()
        else:
            pg.fill(*self.fill_col)

        pen.rect(PVector(self.x, self.y), self.w, self.h)




# A Mondrian Rectangle class
# https://en.wikipedia.org/wiki/Piet_Mondrian
class MondrianRect(Rect):
    def __init__(self, x, y, w, h, strk_col, fill_col=None):
        super(MondrianRect, self).__init__(x, y, w, h, strk_col, fill_col)
        
    # step is the minimum size a mondrian rect can be split down to
    # m is the margin between rects
    def split_random(self, step, m):
        if random(1) < 0.15:
            return
        
        if random(1) < 0.5 and self.w >= (2 * step):
            return self.split_x(int(random(step, self.w - step)), m)
        elif self.h >= (2 * step):
            return self.split_y(int(random(step, self.h - step)), m)
            
    def split_x(self, s, m):
        self.w = self.w - s - m
        return MondrianRect(self.x + self.w + m, self.y, s, self.h, self.strk_col, self.fill_col)
    
    
    def split_y(self, s, m):
        self.h = self.h - s - m
        return MondrianRect(self.x, self.y + self.h + m, self.w, s, self.strk_col, self.fill_col)
    
# A class for generating a Mondrian Rectangle layout
class Mondrian:

    # n is the number of rects which shall be colored or circle packed
    def __init__(self, x, y, w, h, n, strk_col, margin=0, fill_col=None, colors=None, circle_pack=False, n_col=0):
        self.rects = [MondrianRect(x, y, w, h, strk_col, fill_col)]
        self.n = n
        self.n_col = n_col
        self.colors = colors
        self.circle_pack = circle_pack
        self.margin = margin

    # Generate Mondrian layout
    def generate(self):
        for _ in range(self.n):
            for i in range(len(self.rects)-1, -1, -1):
                rect = self.rects[i].split_random(25, self.margin)
                if rect:
                    self.rects.append(rect)


        colored = []
        for _  in range(self.n_col):

            r = int(random(len(self.rects)))
            col = self.colors[int(random(len(self.colors)))] if self.colors else strk_col
            
            
            if self.circle_pack:
                self.rects[r].circle_pack(col)
            else:
                self.rects[r].fill_col = col
        
    def draw(self, pen):
        for rect in self.rects:
            rect.draw(pen)


class CirclePack:

    # Pack a bounding box with circles
    # x, y, w, h define the bounding box.
    # n is number of intended circles in box (not guaranteed)
    # minr, maxr is the minimum and maximum radius of generated circles
    # strk_col, fill_col is colors of circle. If fill_col is None, noFill() is used        
    def __init__(self, x, y, w, h, n, minr, maxr):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.n = n
        self.minr = minr
        self.maxr = maxr
        self.circles = []

    def generate(self):
        circles = []
        for _ in range(self.n):
            for _ in range(100):
                flag = False
                c = Circle(random(self.x, self.x+self.w), random(self.y, self.y+self.h), self.maxr)
                
                if c.inside_list(circles):
                    continue

                while c.intersects_list(circles) or c.x + c.r >= self.x+self.w or c.x - c.r <= self.x or c.y + c.r >= self.y+self.h or c.y - c.r <= self.y:
                    c.r -= 1
                    if c.r < self.minr:
                        flag = True
                        break
                    
                if flag:
                    continue
                    
                circles.append(c)
                break
            
        self.circles = circles
        return circles

    def draw(self, pen):
        for c in self.circles:
            c.draw(pen)



class NBezier:
    def __init__(self, vs1, vs2, ve1, ve2, n):
        
        self.xs1 = vs1.x
        self.xs2 = vs2.x
        self.ys1 = vs1.y
        self.ys2 = vs2.y
        self.xe1 = ve1.x
        self.xe2 = ve2.x
        self.ye1 = ve1.y
        self.ye2 = ve2.y
        self.n = n
        
    def draw(self, pen):
        pg = pen.pg
        pg.noFill()
        
        xs1_ = int(min(self.xs1, self.xs2))
        xs2_ = int(max(self.xs1, self.xs2))
        
        ys1_ = int(min(self.ys1, self.ys2))
        ys2_ = int(max(self.ys1, self.ys2))
        
        xe1_ = int(min(self.xe1, self.xe2))
        xe2_ = int(max(self.xe1, self.xe2))
        
        ye1_ = int(min(self.ye1, self.ye2))
        ye2_ = int(max(self.ye1, self.ye2))    
        
        xss = []
        xes = []
        yss = []
        yes = []
        
        if abs(xs1_ - xs2_) >= self.n:
            xss = list(range(xs1_, xs2_, abs(xs1_-xs2_) / (self.n-1)))
        elif abs(xs1_ - xs2_) < self.n:
            diff = xs1_ - xs2_
            xss = [xs1_ + i * diff / (self.n-1) for i in range(self.n)]
            
        if abs(xe1_ -xe2_) >= self.n:
            xes = list(range(xe1_, xe2_, abs(xe1_-xe2_) / (self.n-1)))
        elif abs(xe1_ - xe2_) < self.n:
            diff = xe1_ - xe2_
            xes = [xe1_ + i * diff / (self.n-1) for i in range(self.n)]
            
        if abs(ys1_ - ys2_) >= self.n:
            yss = list(range(ys1_, ys2_, abs(ys1_-ys2_) / (self.n-1)))
        elif abs(ys1_ - ys2_) < self.n:
            diff = ys1_ - ys2_
            yss = [ys1_ + i * diff / (self.n-1) for i in range(self.n)]
            
        if abs(ye1_ - ye2_) >= self.n:
            yes = list(range(ye1_, ye2_, abs(ye1_-ye2_) / (self.n-1)))
        elif abs(ye1_ - ye2_) < self.n:
            diff = ye1_ - ye2_
            yes = [ye1_ + i * diff / (self.n-1) for i in range(self.n)]
            
        xss.append(self.xs2)
        yss.append(self.ys2)
        xes.append(self.xe2)
        yes.append(self.ye2)
        
        for xs, ys, xe, ye in zip(xss, yss, xes, yes):
            cpx1 = xs
            cpy1 = ye
            
            cpx2 = xs
            cpy2 = ye
            pen.bezier(PVector(xs, ys), PVector(cpx1, cpy1), PVector(cpx2, cpy2), PVector(xe, ye))