from __future__ import division
import pens

class Circle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
        
    def intersects(self, other):
        return (self.x-other.x)**2 + (self.y-other.y)**2 <= (self.r+other.r)**2 
    
    # Takes a circle or x, y coordinates
    # Returns true if argument has origin inside self circle
    def inside(self, c_or_x, y=None):
        if y is None:
            x = c_or_x.x
            y = c_or_x.y
        else:
            x = c_or_x
        
        return (sq(self.x - x) + sq(self.y - y)) < sq(self.r)
    
    def inside_list(self, circles):
        for c in circles:
            if c.inside(self):
                return True
        return False
    
    def intersects_list(self, circles):
        for c in circles:
            if self.intersects(c):
                return True
        return False
    
    def draw(self, pen):
        pen.circle(PVector(self.x, self.y), self.r)


class Rect(object):
    def __init__(self, x, y, w, h):
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def inside(self, v):
        return self.x < v.x < self.x + self.w and self.y < v.y < self.y + self.h




# A Mondrian Rectangle class
# https://en.wikipedia.org/wiki/Piet_Mondrian
class MondrianRect(Rect):
    def __init__(self, x, y, w, h, strk_col, fill_col=None):
        self.strk_col = strk_col
        self.fill_col = fill_col
        super(MondrianRect, self).__init__(x, y, w, h)
        
    # step is the minimum size a mondrian rect can be split down to
    # m is the margin between rects
    def split_random(self, step, m):
        if random(1) < 0.15:
            return
        
        if random(1) < 0.5 and self.w >= (2 * step):
            return self.split_x(int(random(step, self.w - step)), m)
        elif self.h >= (2 * step):
            return self.split_y(int(random(step, self.h - step)), m)
            
    def split_x(self, s, m):
        self.w = self.w - s - m
        return MondrianRect(self.x + self.w + m, self.y, s, self.h, self.strk_col, self.fill_col)
    
    
    def split_y(self, s, m):
        self.h = self.h - s - m
        return MondrianRect(self.x, self.y + self.h + m, self.w, s, self.strk_col, self.fill_col)
    
# A class for generating a Mondrian Rectangle layout
class Mondrian:

    # n is the number of rects which shall be colored or circle packed
    def __init__(self, x, y, w, h, n, strk_col, margin=0, fill_col=None, colors=None, circle_pack=False, n_col=0):
        self.rects = [MondrianRect(x, y, w, h, strk_col, fill_col)]
        self.n = n
        self.n_col = n_col
        self.colors = colors
        self.circle_pack = circle_pack
        self.margin = margin

    # Generate Mondrian layout
    def generate(self):
        for _ in range(self.n):
            for i in range(len(self.rects)-1, -1, -1):
                rect = self.rects[i].split_random(25, self.margin)
                if rect:
                    self.rects.append(rect)


        colored = []
        for _  in range(self.n_col):
            r = int(random(len(self.rects)))
            col = self.colors[int(random(len(self.colors)))] if self.colors else strk_col
            
            
            if self.circle_pack:
                self.rects[r].circle_pack(col)
            else:
                self.rects[r].fill_col = col
        
    def draw(self, pen):
        for rect in self.rects:
            rect.draw(pen)

    def panto(self, pen):
        coords = []
        for rect in self.rects:
            coords.extend(pen.rect_panto(PVector(rect.x, rect.y), rect.w, rect.h))
        return coords


class CirclePack:

    # Pack a bounding box with circles
    # x, y, w, h define the bounding box.
    # n is number of intended circles in box (not guaranteed)
    # minr, maxr is the minimum and maximum radius of generated circles
    # strk_col, fill_col is colors of circle. If fill_col is None, noFill() is used        
    def __init__(self, x, y, w, h, n, minr, maxr):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.n = n
        self.minr = minr
        self.maxr = maxr
        self.circles = []

    def generate(self):
        circles = []
        for _ in range(self.n):
            for _ in range(100):
                flag = False
                c = Circle(random(self.x, self.x+self.w), random(self.y, self.y+self.h), self.maxr)
                
                if c.inside_list(circles):
                    continue

                while c.intersects_list(circles) or c.x + c.r >= self.x+self.w or c.x - c.r <= self.x or c.y + c.r >= self.y+self.h or c.y - c.r <= self.y:
                    c.r -= 1
                    if c.r < self.minr:
                        flag = True
                        break
                    
                if flag:
                    continue
                    
                circles.append(c)
                break
            
        self.circles = circles
        return circles

    def draw(self, pen):
        for c in self.circles:
            c.draw(pen)



class NBezier:
    def __init__(self, vs1, vs2, ve1, ve2, n):
        
        self.xs1 = vs1.x
        self.xs2 = vs2.x
        self.ys1 = vs1.y
        self.ys2 = vs2.y
        self.xe1 = ve1.x
        self.xe2 = ve2.x
        self.ye1 = ve1.y
        self.ye2 = ve2.y
        self.n = n
        
    def draw(self, pen):
        pg = pen.pg
        pg.noFill()
        
        xs1_ = int(min(self.xs1, self.xs2))
        xs2_ = int(max(self.xs1, self.xs2))
        
        ys1_ = int(min(self.ys1, self.ys2))
        ys2_ = int(max(self.ys1, self.ys2))
        
        xe1_ = int(min(self.xe1, self.xe2))
        xe2_ = int(max(self.xe1, self.xe2))
        
        ye1_ = int(min(self.ye1, self.ye2))
        ye2_ = int(max(self.ye1, self.ye2))    
        
        xss = []
        xes = []
        yss = []
        yes = []
        
        if abs(xs1_ - xs2_) >= self.n:
            xss = list(range(xs1_, xs2_, abs(xs1_-xs2_) // (self.n-1)))
        elif abs(xs1_ - xs2_) < self.n:
            diff = xs1_ - xs2_
            xss = [xs1_ + i * diff / (self.n-1) for i in range(self.n)]
            
        if abs(xe1_ -xe2_) >= self.n:
            xes = list(range(xe1_, xe2_, abs(xe1_-xe2_) // (self.n-1)))
        elif abs(xe1_ - xe2_) < self.n:
            diff = xe1_ - xe2_
            xes = [xe1_ + i * diff / (self.n-1) for i in range(self.n)]
            
        if abs(ys1_ - ys2_) >= self.n:
            yss = list(range(ys1_, ys2_, abs(ys1_-ys2_) // (self.n-1)))
        elif abs(ys1_ - ys2_) < self.n:
            diff = ys1_ - ys2_
            yss = [ys1_ + i * diff / (self.n-1) for i in range(self.n)]
            
        if abs(ye1_ - ye2_) >= self.n:
            yes = list(range(ye1_, ye2_, abs(ye1_-ye2_) // (self.n-1)))
        elif abs(ye1_ - ye2_) < self.n:
            diff = ye1_ - ye2_
            yes = [ye1_ + i * diff / (self.n-1) for i in range(self.n)]
            
        xss.append(self.xs2)
        yss.append(self.ys2)
        xes.append(self.xe2)
        yes.append(self.ye2)
        
        for xs, ys, xe, ye in zip(xss, yss, xes, yes):
            cpx1 = xs
            cpy1 = ye
            
            cpx2 = xs
            cpy2 = ye
            pen.bezier(PVector(xs, ys), PVector(cpx1, cpy1), PVector(cpx2, cpy2), PVector(xe, ye))


# Regular Polygon.
# Rewritten to Python.
# Source: https://sighack.com/post/generative-watercolor-in-processing
class RPolygon(object):
    # Initializes a regular polygon with n sides
    def __init__(self, x, y, r, n):
        self.points = []
        self.n = n
        self.r = r
        angle = TWO_PI / self.n
        a = 0

        while a < TWO_PI:
            sx = x + cos(a) * r
            sy = y + sin(a) * r
            self.points.append(PVector(sx, sy))

            a += angle

# Deformed polygon. Is only deformed after calling the deform function.
# Rewritten to Python.
# Source: https://sighack.com/post/generative-watercolor-in-processing
class DeformedPolygon(RPolygon):
    def __init__(self, x, y, r, n):
        super(DeformedPolygon, self).__init__(x, y, r, n)

    def deform_inplace(self, depth=None, variance=None, vdiv=None):
        self.points = self.deform(depth, variance, vdiv)

    def deform(self, depth=None, variance=None, vdiv=None):
        if depth is None:
            depth = 5
        if variance is None:
            variance = self.r / 10
        if vdiv is None:
            vdiv = 2

        sx1 = sy1 = sx2 = sy2 = 0

        new_points = []

        if not self.points:
            return new_points

        # Iterate over existing edges in a pairwise fashion
        for i in range(self.n):
            sx1 = self.points[i].x
            sy1 = self.points[i].y
            sx2 = self.points[(i + 1) % self.n].x
            sy2 = self.points[(i + 1) % self.n].y

            new_points.append(PVector(sx1, sy1))

            self._subdivide(new_points, sx1, sy1, sx2, sy2, depth, variance, vdiv)
        
        new = DeformedPolygon(0, 0, self.r, self.n)
        new.points = new_points
        return new

    # Recursively subdivide a line from (x1, y1) to (x2, y2) to a
    # given depth using a specified variance.
    def _subdivide(self, new_points, x1, y1, x2, y2, depth, variance, vdiv):
        if depth < 0:
            return

        # Find the midpoint of the two points comprising the edge
        midx = (x1 + x2) / 2
        midy = (y1 + y2) / 2

        # Move the midpoint by a Gaussian variance
        nx = midx + randomGaussian() * variance
        ny = midy + randomGaussian() * variance

        # Add two new edges which are recursively subdivided
        self._subdivide(new_points, x1, y1, nx, ny, depth - 1, variance / vdiv, vdiv)
        new_points.append(PVector(nx, ny))
        self._subdivide(new_points, nx, ny, x2, y2, depth - 1, variance / vdiv, vdiv)

# Stack of deformed polygons.
# Rewritten to Python.
# Source: https://sighack.com/post/generative-watercolor-in-processing
class DeformedPolygonStack(object):
    def __init__(self, x, y, r, n, stack_size):
        base = DeformedPolygon(x, y, r, n)
        base.deform_inplace()

        self.polygons = [base.deform() for _ in range(stack_size)]


class FlowFieldItem:
    def __init__(self, pos, angle):
        self.pos = pos
        self.angle = angle


# Source: https://tylerxhobbs.com/essays/2020/flow-fields
class FlowField:
    def __init__(self, x, y, w, h):
        self.ul = PVector(x , y)
        self.lr = PVector(x + 1 * w, y + 1 * h)
        
        self.resolution = min(w, h) * 0.005

        self.num_columns = int((self.lr.x - self.ul.x) / self.resolution)
        self.num_rows = int((self.lr.y - self.ul.y) / self.resolution)

        self.grid = [[None for _ in range(self.num_rows)] for _ in range(self.num_columns)]
        
        self.DEFAULT_ANGLE = PI

        x = self.ul.x
        for col in range(self.num_columns):
            y = self.ul.y
            for row in range(self.num_rows):
                self.grid[col][row] = FlowFieldItem(PVector(x, y), self.DEFAULT_ANGLE)
                
                y += self.resolution

            x += self.resolution

    def set_angles(self, func):
        for col in range(self.num_columns):
            for row in range(self.num_rows):
                self.grid[col][row].angle = func(col, row)


    def curve(self, v_, num_steps, step_ratio=0.01):

        step_length = step_ratio * (self.lr.x - self.ul.x)
        points = []

        v = PVector(v_.x, v_.y)

        for n in range(num_steps+1):

            points.append(v)

            x_offset = v.x - self.ul.x
            y_offset = v.y - self.ul.y

            column_index = int(x_offset / self.resolution)
            row_index = int(y_offset / self.resolution)

            if not 0 <= column_index < self.num_columns or not 0 <= row_index < self.num_rows:
                break

            grid_angle = self.grid[column_index][row_index].angle

            x_step = step_length * cos(grid_angle)
            y_step = step_length * sin(grid_angle)

            v = PVector(v.x + x_step, v.y + y_step)

            if v.x < self.ul.x:
                v.x = self.ul.x
                break

            elif v.x > self.lr.x:
                v.x = self.lr.x
                break

            if v.y < self.ul.y:
                v.y = self.ul.y
                break

            elif v.y > self.lr.y:
                v.y = self.lr.y
                break


        return points

    def angle(self, v):
        x_offset = v.x - self.ul.x
        y_offset = v.y - self.ul.y
        column_index = int(x_offset / self.resolution)
        row_index = int(y_offset / self.resolution)

        if not 0 <= column_index < self.num_columns or not 0 <= row_index < self.num_rows:
            raise ValueError('FlowField.angle index out of bounds')

        return self.grid[column_index][row_index].angle


class RandomPolygon(object):
    def __init__(self, c, w, h, n):
        self.c = c
        self.w = w
        self.h = h

        points_ = [PVector(random(c.x - w / 2, c.x + w / 2), random(c.y - h / 2, c.y + h / 2)) for _ in range(n)]
        avg_x = sum(v.x for v in points_) / len(points_)
        avg_y = sum(v.y for v in points_) / len(points_)
        center_of_gravity = PVector(avg_x, avg_y)

        self.points = sorted(points_, key=lambda v: (v - center_of_gravity).heading())


class CircularRandomPolygon(object):
    def __init__(self, c, r, n):
        self.c = c
        self.r = r

        angle = TWO_PI / n
        start_angle = random(TWO_PI)

        self.points = []

        a = start_angle
        i = 0
        while a < TWO_PI + start_angle and i < n:
            self.points.append(PVector(c.x + cos(a) * r * random(0.3, 1), c.y + sin(a) * r * random(0.3, 1)))
            a += angle * random(0.85, 1.15)
            i += 1
