class Circle:
    def __init__(self, x, y, r, strk_col, fill_col=None):
        self.x = x
        self.y = y
        self.r = r
        self.strk_col = strk_col
        self.fill_col = fill_col
        
    def intersects(self, other):
        return (self.x-other.x)**2 + (self.y-other.y)**2 <= (self.r+other.r)**2 
    
    # Takes a circle or x, y coordinates
    # Returns true if argument has origin inside self circle
    def inside(self, c_or_x, y=None):
        if y is None:
            x = c_or_x.x
            y = c_or_x.y
        else:
            x = c_or_x
        
        return (sq(self.x - x) + sq(self.y - y)) < sq(self.r)
    
    def inside_list(self, circles):
        for c in circles:
            if c.inside(self):
                return True
        return False
    
    def intersects_list(self, circles):
        for c in circles:
            if self.intersects(c):
                return True
        return False
    
    def draw(self, pen):
        pg = pen.pg

        pg.stroke(*self.strk_col)
        if self.fill_col is None:
            pg.noFill()
        else:
            pg.fill(*self.fill_col)
        
        pen.circle(PVector(self.x, self.y), self.r)


class Rect(object):
    def __init__(self, x, y, w, h, strk_col, fill_col=None):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.strk_col = strk_col
        self.fill_col = fill_col
        self.circles = []
        
    def circle_pack(self, col):
        self.circles = CirclePack(self.x, self.y, self.w, self.h, 100, 2, 100, col).generate()

    def draw(self, pen):
        pg = pen.pg

        for c in self.circles:
            c.draw(pen)

        pg.stroke(*self.strk_col)

        if self.fill_col is None:
            pg.noFill()
        else:
            pg.fill(*self.fill_col)

        pen.rect(PVector(self.x, self.y), self.w, self.h)




# A Mondrian Rectangle class
# https://en.wikipedia.org/wiki/Piet_Mondrian
class MondrianRect(Rect):
    def __init__(self, x, y, w, h, strk_col, fill_col=None):
        super(MondrianRect, self).__init__(x, y, w, h, strk_col, fill_col)
        
    # step is the minimum size a mondrian rect can be split down to
    # m is the margin between rects
    def split_random(self, step, m):
        if random(1) < 0.15:
            return
        
        if random(1) < 0.5 and self.w >= (2 * step):
            return self.split_x(int(random(step, self.w - step)), m)
        elif self.h >= (2 * step):
            return self.split_y(int(random(step, self.h - step)), m)
            
    def split_x(self, s, m):
        self.w = self.w - s - m
        return MondrianRect(self.x + self.w + m, self.y, s, self.h, self.strk_col, self.fill_col)
    
    
    def split_y(self, s, m):
        self.h = self.h - s - m
        return MondrianRect(self.x, self.y + self.h + m, self.w, s, self.strk_col, self.fill_col)
    
# A class for generating a Mondrian Rectangle layout
class Mondrian:

    # n is the number of rects which shall be colored or circle packed
    def __init__(self, x, y, w, h, n, strk_col, margin=0, fill_col=None, colors=None, circle_pack=False, n_col=0):
        self.rects = [MondrianRect(x, y, w, h, strk_col, fill_col)]
        self.n = n
        self.n_col = n_col
        self.colors = colors
        self.circle_pack = circle_pack
        self.margin = margin

    # Generate Mondrian layout
    def generate(self):
        for _ in range(self.n):
            for i in range(len(self.rects)-1, -1, -1):
                rect = self.rects[i].split_random(25, self.margin)
                if rect:
                    self.rects.append(rect)


        colored = []
        for _  in range(self.n_col):

            r = int(random(len(self.rects)))
            col = self.colors[int(random(len(self.colors)))] if self.colors else strk_col
            
            
            if self.circle_pack:
                self.rects[r].circle_pack(col)
            else:
                self.rects[r].fill_col = col
        
    def draw(self, pen):
        for rect in self.rects:
            rect.draw(pen)


class CirclePack:

    # Pack a bounding box with circles
    # x, y, w, h define the bounding box.
    # n is number of intended circles in box (not guaranteed)
    # minr, maxr is the minimum and maximum radius of generated circles
    # strk_col, fill_col is colors of circle. If fill_col is None, noFill() is used        
    def __init__(self, x, y, w, h, n, minr, maxr, strk_col, fill_col=None):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.n = n
        self.minr = minr
        self.maxr = maxr
        self.strk_col = strk_col
        self.fill_col = fill_col

    def generate(self):
        circles = []
        for _ in range(self.n):
            for _ in range(100):
                flag = False
                c = Circle(random(self.x, self.x+self.w), random(self.y, self.y+self.h), self.maxr, self.strk_col, self.fill_col)
                
                if c.inside_list(circles):
                    continue

                while c.intersects_list(circles) or c.x + c.r >= self.x+self.w or c.x - c.r <= self.x or c.y + c.r >= self.y+self.h or c.y - c.r <= self.y:
                    c.r -= 1
                    if c.r < self.minr:
                        flag = True
                        break
                    
                if flag:
                    continue
                    
                circles.append(c)
                break
            
        return circles





